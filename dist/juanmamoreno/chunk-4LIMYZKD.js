import{a as St,b as Vt,c as Z,d as Pt,e as Q,f as zt,g as k,h as z,j as It,k as At,l as ae,m as J,n as ue}from"./chunk-NNNEJ25Q.js";import{b as oe,c as se,d as mt,e as ie,g as pt,h as Y,i as Et,j as ce,k as Bt,l as fe,n as vt}from"./chunk-NNRL3H2V.js";import{a as V,b as X}from"./chunk-M2AMYXAA.js";function Re(e,n,t,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(n,t,r);let o=BigInt(32),s=BigInt(4294967295),f=Number(t>>o&s),i=Number(t&s),c=r?4:0,a=r?0:4;e.setUint32(n+c,f,r),e.setUint32(n+a,i,r)}var _t=class extends Bt{constructor(n,t,r,o){super(),this.blockLen=n,this.outputLen=t,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=pt(this.buffer)}update(n){mt(this);let{view:t,buffer:r,blockLen:o}=this;n=Et(n);let s=n.length;for(let f=0;f<s;){let i=Math.min(o-this.pos,s-f);if(i===o){let c=pt(n);for(;o<=s-f;f+=o)this.process(c,f);continue}r.set(n.subarray(f,f+i),this.pos),this.pos+=i,f+=i,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){mt(this),ie(n,this),this.finished=!0;let{buffer:t,view:r,blockLen:o,isLE:s}=this,{pos:f}=this;t[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>o-f&&(this.process(r,0),f=0);for(let d=f;d<o;d++)t[d]=0;Re(r,o-8,BigInt(this.length*8),s),this.process(r,0);let i=pt(n),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=c/4,l=this.get();if(a>l.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<a;d++)i.setUint32(4*d,l[d],s)}digest(){let{buffer:n,outputLen:t}=this;this.digestInto(n);let r=n.slice(0,t);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());let{blockLen:t,buffer:r,length:o,finished:s,destroyed:f,pos:i}=this;return n.length=o,n.pos=i,n.finished=s,n.destroyed=f,o%t&&n.buffer.set(r),n}};var He=(e,n,t)=>e&n^~e&t,Ue=(e,n,t)=>e&n^e&t^n&t,Ce=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),rt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ot=new Uint32Array(64),Dt=class extends _t{constructor(){super(64,32,8,!1),this.A=rt[0]|0,this.B=rt[1]|0,this.C=rt[2]|0,this.D=rt[3]|0,this.E=rt[4]|0,this.F=rt[5]|0,this.G=rt[6]|0,this.H=rt[7]|0}get(){let{A:n,B:t,C:r,D:o,E:s,F:f,G:i,H:c}=this;return[n,t,r,o,s,f,i,c]}set(n,t,r,o,s,f,i,c){this.A=n|0,this.B=t|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=f|0,this.G=i|0,this.H=c|0}process(n,t){for(let d=0;d<16;d++,t+=4)ot[d]=n.getUint32(t,!1);for(let d=16;d<64;d++){let I=ot[d-15],B=ot[d-2],w=Y(I,7)^Y(I,18)^I>>>3,u=Y(B,17)^Y(B,19)^B>>>10;ot[d]=u+ot[d-7]+w+ot[d-16]|0}let{A:r,B:o,C:s,D:f,E:i,F:c,G:a,H:l}=this;for(let d=0;d<64;d++){let I=Y(i,6)^Y(i,11)^Y(i,25),B=l+I+He(i,c,a)+Ce[d]+ot[d]|0,u=(Y(r,2)^Y(r,13)^Y(r,22))+Ue(r,o,s)|0;l=a,a=c,c=i,i=f+B|0,f=s,s=o,o=r,r=B+u|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,f=f+this.D|0,i=i+this.E|0,c=c+this.F|0,a=a+this.G|0,l=l+this.H|0,this.set(r,o,s,f,i,c,a,l)}roundClean(){ot.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var gt=fe(()=>new Dt);var U=BigInt(0),L=BigInt(1),at=BigInt(2),Ze=BigInt(3),jt=BigInt(4),de=BigInt(5),le=BigInt(8),ke=BigInt(9),Ve=BigInt(16);function H(e,n){let t=e%n;return t>=U?t:n+t}function Pe(e,n,t){if(t<=U||n<U)throw new Error("Expected power/modulo > 0");if(t===L)return U;let r=L;for(;n>U;)n&L&&(r=r*e%t),e=e*e%t,n>>=L;return r}function $(e,n,t){let r=e;for(;n-- >U;)r*=r,r%=t;return r}function Ot(e,n){if(e===U||n<=U)throw new Error(`invert: expected positive integers, got n=${e} mod=${n}`);let t=H(e,n),r=n,o=U,s=L,f=L,i=U;for(;t!==U;){let a=r/t,l=r%t,d=o-f*a,I=s-i*a;r=t,t=l,o=f,s=i,f=d,i=I}if(r!==L)throw new Error("invert: does not exist");return H(o,n)}function ze(e){let n=(e-L)/at,t,r,o;for(t=e-L,r=0;t%at===U;t/=at,r++);for(o=at;o<e&&Pe(o,n,e)!==e-L;o++);if(r===1){let f=(e+L)/jt;return function(c,a){let l=c.pow(a,f);if(!c.eql(c.sqr(l),a))throw new Error("Cannot find square root");return l}}let s=(t+L)/at;return function(i,c){if(i.pow(c,n)===i.neg(i.ONE))throw new Error("Cannot find square root");let a=r,l=i.pow(i.mul(i.ONE,o),t),d=i.pow(c,s),I=i.pow(c,t);for(;!i.eql(I,i.ONE);){if(i.eql(I,i.ZERO))return i.ZERO;let B=1;for(let u=i.sqr(I);B<a&&!i.eql(u,i.ONE);B++)u=i.sqr(u);let w=i.pow(l,L<<BigInt(a-B-1));l=i.sqr(w),d=i.mul(d,w),I=i.mul(I,l),a=B}return d}}function De(e){if(e%jt===Ze){let n=(e+L)/jt;return function(r,o){let s=r.pow(o,n);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(e%le===de){let n=(e-de)/le;return function(r,o){let s=r.mul(o,at),f=r.pow(s,n),i=r.mul(o,f),c=r.mul(r.mul(i,at),f),a=r.mul(i,r.sub(c,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return e%Ve,ze(e)}var je=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function qt(e){let n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=je.reduce((r,o)=>(r[o]="function",r),n);return J(e,t)}function Ke(e,n,t){if(t<U)throw new Error("Expected power > 0");if(t===U)return e.ONE;if(t===L)return n;let r=e.ONE,o=n;for(;t>U;)t&L&&(r=e.mul(r,o)),o=e.sqr(o),t>>=L;return r}function Me(e,n){let t=new Array(n.length),r=n.reduce((s,f,i)=>e.is0(f)?s:(t[i]=s,e.mul(s,f)),e.ONE),o=e.inv(r);return n.reduceRight((s,f,i)=>e.is0(f)?s:(t[i]=e.mul(s,t[i]),e.mul(s,f)),o),t}function Kt(e,n){let t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function he(e,n,t=!1,r={}){if(e<=U)throw new Error(`Expected Field ORDER > 0, got ${e}`);let{nBitLength:o,nByteLength:s}=Kt(e,n);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");let f=De(e),i=Object.freeze({ORDER:e,BITS:o,BYTES:s,MASK:At(o),ZERO:U,ONE:L,create:c=>H(c,e),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return U<=c&&c<e},is0:c=>c===U,isOdd:c=>(c&L)===L,neg:c=>H(-c,e),eql:(c,a)=>c===a,sqr:c=>H(c*c,e),add:(c,a)=>H(c+a,e),sub:(c,a)=>H(c-a,e),mul:(c,a)=>H(c*a,e),pow:(c,a)=>Ke(i,c,a),div:(c,a)=>H(c*Ot(a,e),e),sqrN:c=>c*c,addN:(c,a)=>c+a,subN:(c,a)=>c-a,mulN:(c,a)=>c*a,inv:c=>Ot(c,e),sqrt:r.sqrt||(c=>f(i,c)),invertBatch:c=>Me(i,c),cmov:(c,a,l)=>l?a:c,toBytes:c=>t?zt(c,s):Q(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return t?Pt(c):Z(c)}});return Object.freeze(i)}function me(e){if(typeof e!="bigint")throw new Error("field order must be bigint");let n=e.toString(2).length;return Math.ceil(n/8)}function Mt(e){let n=me(e);return n+Math.ceil(n/2)}function be(e,n,t=!1){let r=e.length,o=me(n),s=Mt(n);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);let f=t?Z(e):Pt(e),i=H(f,n-L)+L;return t?zt(i,o):Q(i,o)}var Ye=BigInt(0),$t=BigInt(1);function ge(e,n){let t=(o,s)=>{let f=s.negate();return o?f:s},r=o=>{let s=Math.ceil(n/o)+1,f=2**(o-1);return{windows:s,windowSize:f}};return{constTimeNegate:t,unsafeLadder(o,s){let f=e.ZERO,i=o;for(;s>Ye;)s&$t&&(f=f.add(i)),i=i.double(),s>>=$t;return f},precomputeWindow(o,s){let{windows:f,windowSize:i}=r(s),c=[],a=o,l=a;for(let d=0;d<f;d++){l=a,c.push(l);for(let I=1;I<i;I++)l=l.add(a),c.push(l);a=l.double()}return c},wNAF(o,s,f){let{windows:i,windowSize:c}=r(o),a=e.ZERO,l=e.BASE,d=BigInt(2**o-1),I=2**o,B=BigInt(o);for(let w=0;w<i;w++){let u=w*c,m=Number(f&d);f>>=B,m>c&&(m-=I,f+=$t);let h=u,g=u+Math.abs(m)-1,y=w%2!==0,v=m<0;m===0?l=l.add(t(y,s[h])):a=a.add(t(v,s[g]))}return{p:a,f:l}},wNAFCached(o,s,f,i){let c=o._WINDOW_SIZE||1,a=s.get(o);return a||(a=this.precomputeWindow(o,c),c!==1&&s.set(o,i(a))),this.wNAF(c,a,f)}}}function Yt(e){return qt(e.Fp),J(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze(X(V(V({},Kt(e.n,e.nBitLength)),e),{p:e.Fp.ORDER}))}function Ge(e){let n=Yt(e);J(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:t,Fp:r,a:o}=n;if(t){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze(V({},n))}var{bytesToNumberBE:We,hexToBytes:Xe}=ue,ut={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(e){let{Err:n}=ut;if(e.length<2||e[0]!==2)throw new n("Invalid signature integer tag");let t=e[1],r=e.subarray(2,t+2);if(!t||r.length!==t)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:We(r),l:e.subarray(t+2)}},toSig(e){let{Err:n}=ut,t=typeof e=="string"?Xe(e):e;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let r=t.length;if(r<2||t[0]!=48)throw new n("Invalid signature tag");if(t[1]!==r-2)throw new n("Invalid signature: incorrect length");let{d:o,l:s}=ut._parseInt(t.subarray(2)),{d:f,l:i}=ut._parseInt(s);if(i.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s:f}},hexFromSig(e){let n=a=>Number.parseInt(a[0],16)&8?"00"+a:a,t=a=>{let l=a.toString(16);return l.length&1?`0${l}`:l},r=n(t(e.s)),o=n(t(e.r)),s=r.length/2,f=o.length/2,i=t(s),c=t(f);return`30${t(f+s+4)}02${c}${o}02${i}${r}`}},G=BigInt(0),R=BigInt(1),st=BigInt(2),Nt=BigInt(3),we=BigInt(4);function Qe(e){let n=Ge(e),{Fp:t}=n,r=n.toBytes||((w,u,m)=>{let h=u.toAffine();return z(Uint8Array.from([4]),t.toBytes(h.x),t.toBytes(h.y))}),o=n.fromBytes||(w=>{let u=w.subarray(1),m=t.fromBytes(u.subarray(0,t.BYTES)),h=t.fromBytes(u.subarray(t.BYTES,2*t.BYTES));return{x:m,y:h}});function s(w){let{a:u,b:m}=n,h=t.sqr(w),g=t.mul(h,w);return t.add(t.add(g,t.mul(w,u)),m)}if(!t.eql(t.sqr(n.Gy),s(n.Gx)))throw new Error("bad generator point: equation left != right");function f(w){return typeof w=="bigint"&&G<w&&w<n.n}function i(w){if(!f(w))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(w){let{allowedPrivateKeyLengths:u,nByteLength:m,wrapPrivateKey:h,n:g}=n;if(u&&typeof w!="bigint"){if(w instanceof Uint8Array&&(w=St(w)),typeof w!="string"||!u.includes(w.length))throw new Error("Invalid key");w=w.padStart(m*2,"0")}let y;try{y=typeof w=="bigint"?w:Z(k("private key",w,m))}catch{throw new Error(`private key must be ${m} bytes, hex or bigint, not ${typeof w}`)}return h&&(y=H(y,g)),i(y),y}let a=new Map;function l(w){if(!(w instanceof d))throw new Error("ProjectivePoint expected")}class d{constructor(u,m,h){if(this.px=u,this.py=m,this.pz=h,u==null||!t.isValid(u))throw new Error("x required");if(m==null||!t.isValid(m))throw new Error("y required");if(h==null||!t.isValid(h))throw new Error("z required")}static fromAffine(u){let{x:m,y:h}=u||{};if(!u||!t.isValid(m)||!t.isValid(h))throw new Error("invalid affine point");if(u instanceof d)throw new Error("projective point not allowed");let g=y=>t.eql(y,t.ZERO);return g(m)&&g(h)?d.ZERO:new d(m,h,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){let m=t.invertBatch(u.map(h=>h.pz));return u.map((h,g)=>h.toAffine(m[g])).map(d.fromAffine)}static fromHex(u){let m=d.fromAffine(o(k("pointHex",u)));return m.assertValidity(),m}static fromPrivateKey(u){return d.BASE.multiply(c(u))}_setWindowSize(u){this._WINDOW_SIZE=u,a.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}let{x:u,y:m}=this.toAffine();if(!t.isValid(u)||!t.isValid(m))throw new Error("bad point: x or y not FE");let h=t.sqr(m),g=s(u);if(!t.eql(h,g))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:u}=this.toAffine();if(t.isOdd)return!t.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){l(u);let{px:m,py:h,pz:g}=this,{px:y,py:v,pz:A}=u,p=t.eql(t.mul(m,A),t.mul(y,g)),E=t.eql(t.mul(h,A),t.mul(v,g));return p&&E}negate(){return new d(this.px,t.neg(this.py),this.pz)}double(){let{a:u,b:m}=n,h=t.mul(m,Nt),{px:g,py:y,pz:v}=this,A=t.ZERO,p=t.ZERO,E=t.ZERO,S=t.mul(g,g),P=t.mul(y,y),T=t.mul(v,v),O=t.mul(g,y);return O=t.add(O,O),E=t.mul(g,v),E=t.add(E,E),A=t.mul(u,E),p=t.mul(h,T),p=t.add(A,p),A=t.sub(P,p),p=t.add(P,p),p=t.mul(A,p),A=t.mul(O,A),E=t.mul(h,E),T=t.mul(u,T),O=t.sub(S,T),O=t.mul(u,O),O=t.add(O,E),E=t.add(S,S),S=t.add(E,S),S=t.add(S,T),S=t.mul(S,O),p=t.add(p,S),T=t.mul(y,v),T=t.add(T,T),S=t.mul(T,O),A=t.sub(A,S),E=t.mul(T,P),E=t.add(E,E),E=t.add(E,E),new d(A,p,E)}add(u){l(u);let{px:m,py:h,pz:g}=this,{px:y,py:v,pz:A}=u,p=t.ZERO,E=t.ZERO,S=t.ZERO,P=n.a,T=t.mul(n.b,Nt),O=t.mul(m,y),D=t.mul(h,v),j=t.mul(g,A),F=t.add(m,h),b=t.add(y,v);F=t.mul(F,b),b=t.add(O,D),F=t.sub(F,b),b=t.add(m,g);let x=t.add(y,A);return b=t.mul(b,x),x=t.add(O,j),b=t.sub(b,x),x=t.add(h,g),p=t.add(v,A),x=t.mul(x,p),p=t.add(D,j),x=t.sub(x,p),S=t.mul(P,b),p=t.mul(T,j),S=t.add(p,S),p=t.sub(D,S),S=t.add(D,S),E=t.mul(p,S),D=t.add(O,O),D=t.add(D,O),j=t.mul(P,j),b=t.mul(T,b),D=t.add(D,j),j=t.sub(O,j),j=t.mul(P,j),b=t.add(b,j),O=t.mul(D,b),E=t.add(E,O),O=t.mul(x,b),p=t.mul(F,p),p=t.sub(p,O),O=t.mul(F,D),S=t.mul(x,S),S=t.add(S,O),new d(p,E,S)}subtract(u){return this.add(u.negate())}is0(){return this.equals(d.ZERO)}wNAF(u){return B.wNAFCached(this,a,u,m=>{let h=t.invertBatch(m.map(g=>g.pz));return m.map((g,y)=>g.toAffine(h[y])).map(d.fromAffine)})}multiplyUnsafe(u){let m=d.ZERO;if(u===G)return m;if(i(u),u===R)return this;let{endo:h}=n;if(!h)return B.unsafeLadder(this,u);let{k1neg:g,k1:y,k2neg:v,k2:A}=h.splitScalar(u),p=m,E=m,S=this;for(;y>G||A>G;)y&R&&(p=p.add(S)),A&R&&(E=E.add(S)),S=S.double(),y>>=R,A>>=R;return g&&(p=p.negate()),v&&(E=E.negate()),E=new d(t.mul(E.px,h.beta),E.py,E.pz),p.add(E)}multiply(u){i(u);let m=u,h,g,{endo:y}=n;if(y){let{k1neg:v,k1:A,k2neg:p,k2:E}=y.splitScalar(m),{p:S,f:P}=this.wNAF(A),{p:T,f:O}=this.wNAF(E);S=B.constTimeNegate(v,S),T=B.constTimeNegate(p,T),T=new d(t.mul(T.px,y.beta),T.py,T.pz),h=S.add(T),g=P.add(O)}else{let{p:v,f:A}=this.wNAF(m);h=v,g=A}return d.normalizeZ([h,g])[0]}multiplyAndAddUnsafe(u,m,h){let g=d.BASE,y=(A,p)=>p===G||p===R||!A.equals(g)?A.multiplyUnsafe(p):A.multiply(p),v=y(this,m).add(y(u,h));return v.is0()?void 0:v}toAffine(u){let{px:m,py:h,pz:g}=this,y=this.is0();u==null&&(u=y?t.ONE:t.inv(g));let v=t.mul(m,u),A=t.mul(h,u),p=t.mul(g,u);if(y)return{x:t.ZERO,y:t.ZERO};if(!t.eql(p,t.ONE))throw new Error("invZ was invalid");return{x:v,y:A}}isTorsionFree(){let{h:u,isTorsionFree:m}=n;if(u===R)return!0;if(m)return m(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:u,clearCofactor:m}=n;return u===R?this:m?m(d,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return this.assertValidity(),r(d,this,u)}toHex(u=!0){return St(this.toRawBytes(u))}}d.BASE=new d(n.Gx,n.Gy,t.ONE),d.ZERO=new d(t.ZERO,t.ONE,t.ZERO);let I=n.nBitLength,B=ge(d,n.endo?Math.ceil(I/2):I);return{CURVE:n,ProjectivePoint:d,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:f}}function Je(e){let n=Yt(e);return J(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze(V({lowS:!0},n))}function xe(e){let n=Je(e),{Fp:t,n:r}=n,o=t.BYTES+1,s=2*t.BYTES+1;function f(b){return G<b&&b<t.ORDER}function i(b){return H(b,r)}function c(b){return Ot(b,r)}let{ProjectivePoint:a,normPrivateKeyToScalar:l,weierstrassEquation:d,isWithinCurveOrder:I}=Qe(X(V({},n),{toBytes(b,x,_){let N=x.toAffine(),q=t.toBytes(N.x),C=z;return _?C(Uint8Array.from([x.hasEvenY()?2:3]),q):C(Uint8Array.from([4]),q,t.toBytes(N.y))},fromBytes(b){let x=b.length,_=b[0],N=b.subarray(1);if(x===o&&(_===2||_===3)){let q=Z(N);if(!f(q))throw new Error("Point is not on curve");let C=d(q),K=t.sqrt(C),M=(K&R)===R;return(_&1)===1!==M&&(K=t.neg(K)),{x:q,y:K}}else if(x===s&&_===4){let q=t.fromBytes(N.subarray(0,t.BYTES)),C=t.fromBytes(N.subarray(t.BYTES,2*t.BYTES));return{x:q,y:C}}else throw new Error(`Point of length ${x} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}})),B=b=>St(Q(b,n.nByteLength));function w(b){let x=r>>R;return b>x}function u(b){return w(b)?i(-b):b}let m=(b,x,_)=>Z(b.slice(x,_));class h{constructor(x,_,N){this.r=x,this.s=_,this.recovery=N,this.assertValidity()}static fromCompact(x){let _=n.nByteLength;return x=k("compactSignature",x,_*2),new h(m(x,0,_),m(x,_,2*_))}static fromDER(x){let{r:_,s:N}=ut.toSig(k("DER",x));return new h(_,N)}assertValidity(){if(!I(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!I(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(x){return new h(this.r,this.s,x)}recoverPublicKey(x){let{r:_,s:N,recovery:q}=this,C=E(k("msgHash",x));if(q==null||![0,1,2,3].includes(q))throw new Error("recovery id invalid");let K=q===2||q===3?_+n.n:_;if(K>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let M=q&1?"03":"02",tt=a.fromHex(M+B(K)),et=c(K),dt=i(-C*et),bt=i(N*et),nt=a.BASE.multiplyAndAddUnsafe(tt,dt,bt);if(!nt)throw new Error("point at infinify");return nt.assertValidity(),nt}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return Vt(this.toDERHex())}toDERHex(){return ut.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Vt(this.toCompactHex())}toCompactHex(){return B(this.r)+B(this.s)}}let g={isValidPrivateKey(b){try{return l(b),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{let b=Mt(n.n);return be(n.randomBytes(b),n.n)},precompute(b=8,x=a.BASE){return x._setWindowSize(b),x.multiply(BigInt(3)),x}};function y(b,x=!0){return a.fromPrivateKey(b).toRawBytes(x)}function v(b){let x=b instanceof Uint8Array,_=typeof b=="string",N=(x||_)&&b.length;return x?N===o||N===s:_?N===2*o||N===2*s:b instanceof a}function A(b,x,_=!0){if(v(b))throw new Error("first arg must be private key");if(!v(x))throw new Error("second arg must be public key");return a.fromHex(x).multiply(l(b)).toRawBytes(_)}let p=n.bits2int||function(b){let x=Z(b),_=b.length*8-n.nBitLength;return _>0?x>>BigInt(_):x},E=n.bits2int_modN||function(b){return i(p(b))},S=At(n.nBitLength);function P(b){if(typeof b!="bigint")throw new Error("bigint expected");if(!(G<=b&&b<S))throw new Error(`bigint expected < 2^${n.nBitLength}`);return Q(b,n.nByteLength)}function T(b,x,_=O){if(["recovered","canonical"].some(ft=>ft in _))throw new Error("sign() legacy options not supported");let{hash:N,randomBytes:q}=n,{lowS:C,prehash:K,extraEntropy:M}=_;C==null&&(C=!0),b=k("msgHash",b),K&&(b=k("prehashed msgHash",N(b)));let tt=E(b),et=l(x),dt=[P(et),P(tt)];if(M!=null){let ft=M===!0?q(t.BYTES):M;dt.push(k("extraEntropy",ft))}let bt=z(...dt),nt=tt;function kt(ft){let lt=p(ft);if(!I(lt))return;let ee=c(lt),W=a.BASE.multiply(lt).toAffine(),ht=i(W.x);if(ht===G)return;let yt=i(ee*i(nt+ht*et));if(yt===G)return;let ne=(W.x===ht?0:2)|Number(W.y&R),re=yt;return C&&w(yt)&&(re=u(yt),ne^=1),new h(ht,re,ne)}return{seed:bt,k2sig:kt}}let O={lowS:n.lowS,prehash:!1},D={lowS:n.lowS,prehash:!1};function j(b,x,_=O){let{seed:N,k2sig:q}=T(b,x,_),C=n;return ae(C.hash.outputLen,C.nByteLength,C.hmac)(N,q)}a.BASE._setWindowSize(8);function F(b,x,_,N=D){let q=b;if(x=k("msgHash",x),_=k("publicKey",_),"strict"in N)throw new Error("options.strict was renamed to lowS");let{lowS:C,prehash:K}=N,M,tt;try{if(typeof q=="string"||q instanceof Uint8Array)try{M=h.fromDER(q)}catch(W){if(!(W instanceof ut.Err))throw W;M=h.fromCompact(q)}else if(typeof q=="object"&&typeof q.r=="bigint"&&typeof q.s=="bigint"){let{r:W,s:ht}=q;M=new h(W,ht)}else throw new Error("PARSE");tt=a.fromHex(_)}catch(W){if(W.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(C&&M.hasHighS())return!1;K&&(x=n.hash(x));let{r:et,s:dt}=M,bt=E(x),nt=c(dt),kt=i(bt*nt),ft=i(et*nt),lt=a.BASE.multiplyAndAddUnsafe(tt,kt,ft)?.toAffine();return lt?i(lt.x)===et:!1}return{CURVE:n,getPublicKey:y,getSharedSecret:A,sign:j,verify:F,ProjectivePoint:a,Signature:h,utils:g}}function Fe(e,n){let t=e.ORDER,r=G;for(let w=t-R;w%st===G;w/=st)r+=R;let o=r,s=st<<o-R-R,f=s*st,i=(t-R)/f,c=(i-R)/st,a=f-R,l=s,d=e.pow(n,i),I=e.pow(n,(i+R)/st),B=(w,u)=>{let m=d,h=e.pow(u,a),g=e.sqr(h);g=e.mul(g,u);let y=e.mul(w,g);y=e.pow(y,c),y=e.mul(y,h),h=e.mul(y,u),g=e.mul(y,w);let v=e.mul(g,h);y=e.pow(v,l);let A=e.eql(y,e.ONE);h=e.mul(g,I),y=e.mul(v,m),g=e.cmov(h,g,A),v=e.cmov(y,v,A);for(let p=o;p>R;p--){let E=p-st;E=st<<E-R;let S=e.pow(v,E),P=e.eql(S,e.ONE);h=e.mul(g,m),m=e.mul(m,m),S=e.mul(v,m),g=e.cmov(h,g,P),v=e.cmov(S,v,P)}return{isValid:A,value:g}};if(e.ORDER%we===Nt){let w=(e.ORDER-Nt)/we,u=e.sqrt(e.neg(n));B=(m,h)=>{let g=e.sqr(h),y=e.mul(m,h);g=e.mul(g,y);let v=e.pow(g,w);v=e.mul(v,y);let A=e.mul(v,u),p=e.mul(e.sqr(v),h),E=e.eql(p,m),S=e.cmov(A,v,E);return{isValid:E,value:S}}}return B}function ye(e,n){if(qt(e),!e.isValid(n.A)||!e.isValid(n.B)||!e.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");let t=Fe(e,n.Z);if(!e.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,f,i,c,a,l,d;o=e.sqr(r),o=e.mul(o,n.Z),s=e.sqr(o),s=e.add(s,o),f=e.add(s,e.ONE),f=e.mul(f,n.B),i=e.cmov(n.Z,e.neg(s),!e.eql(s,e.ZERO)),i=e.mul(i,n.A),s=e.sqr(f),a=e.sqr(i),c=e.mul(a,n.A),s=e.add(s,c),s=e.mul(s,f),a=e.mul(a,i),c=e.mul(a,n.B),s=e.add(s,c),l=e.mul(o,f);let{isValid:I,value:B}=t(s,a);d=e.mul(o,r),d=e.mul(d,B),l=e.cmov(l,f,I),d=e.cmov(d,B,I);let w=e.isOdd(r)===e.isOdd(d);return d=e.cmov(e.neg(d),d,w),l=e.div(l,i),{x:l,y:d}}}function tn(e){if(e instanceof Uint8Array)return e;if(typeof e=="string")return It(e);throw new Error("DST must be Uint8Array or string")}var en=Z;function it(e,n){if(e<0||e>=1<<8*n)throw new Error(`bad I2OSP call: value=${e} length=${n}`);let t=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)t[r]=e&255,e>>>=8;return new Uint8Array(t)}function nn(e,n){let t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e[r]^n[r];return t}function wt(e){if(!(e instanceof Uint8Array))throw new Error("Uint8Array expected")}function Gt(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function rn(e,n,t,r){wt(e),wt(n),Gt(t),n.length>255&&(n=r(z(It("H2C-OVERSIZE-DST-"),n)));let{outputLen:o,blockLen:s}=r,f=Math.ceil(t/o);if(f>255)throw new Error("Invalid xmd length");let i=z(n,it(n.length,1)),c=it(0,s),a=it(t,2),l=new Array(f),d=r(z(c,e,a,it(0,1),i));l[0]=r(z(d,it(1,1),i));for(let B=1;B<=f;B++){let w=[nn(d,l[B-1]),it(B+1,1),i];l[B]=r(z(...w))}return z(...l).slice(0,t)}function on(e,n,t,r,o){if(wt(e),wt(n),Gt(t),n.length>255){let s=Math.ceil(2*r/8);n=o.create({dkLen:s}).update(It("H2C-OVERSIZE-DST-")).update(n).digest()}if(t>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:t}).update(e).update(it(t,2)).update(n).update(it(n.length,1)).digest()}function pe(e,n,t){J(t,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});let{p:r,k:o,m:s,hash:f,expand:i,DST:c}=t;wt(e),Gt(n);let a=tn(c),l=r.toString(2).length,d=Math.ceil((l+o)/8),I=n*s*d,B;if(i==="xmd")B=rn(e,a,I,f);else if(i==="xof")B=on(e,a,I,o,f);else if(i==="_internal_pass")B=e;else throw new Error('expand must be "xmd" or "xof"');let w=new Array(n);for(let u=0;u<n;u++){let m=new Array(s);for(let h=0;h<s;h++){let g=d*(h+u*s),y=B.subarray(g,g+d);m[h]=H(en(y),r)}w[u]=m}return w}function Ee(e,n){let t=n.map(r=>Array.from(r).reverse());return(r,o)=>{let[s,f,i,c]=t.map(a=>a.reduce((l,d)=>e.add(e.mul(l,r),d)));return r=e.div(s,f),o=e.mul(o,e.div(i,c)),{x:r,y:o}}}function Be(e,n,t){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){let s=pe(r,2,V(X(V({},t),{DST:t.DST}),o)),f=e.fromAffine(n(s[0])),i=e.fromAffine(n(s[1])),c=f.add(i).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){let s=pe(r,1,V(X(V({},t),{DST:t.encodeDST}),o)),f=e.fromAffine(n(s[0])).clearCofactor();return f.assertValidity(),f}}}var Tt=class extends Bt{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,se(n);let r=Et(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=n.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),s.fill(0)}update(n){return mt(this),this.iHash.update(n),this}digestInto(n){mt(this),oe(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){let n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:r,finished:o,destroyed:s,blockLen:f,outputLen:i}=this;return n=n,n.finished=o,n.destroyed=s,n.blockLen=f,n.outputLen=i,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Wt=(e,n,t)=>new Tt(e,n).update(t).digest();Wt.create=(e,n)=>new Tt(e,n);function sn(e){return{hash:e,hmac:(n,...t)=>Wt(e,n,ce(...t)),randomBytes:vt}}function ve(e,n){let t=r=>xe(V(V({},e),sn(r)));return Object.freeze(X(V({},t(n)),{create:t}))}var Ut=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Lt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ae=BigInt(1),Rt=BigInt(2),Se=(e,n)=>(e+n/Rt)/n;function _e(e){let n=Ut,t=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),f=BigInt(23),i=BigInt(44),c=BigInt(88),a=e*e*e%n,l=a*a*e%n,d=$(l,t,n)*l%n,I=$(d,t,n)*l%n,B=$(I,Rt,n)*a%n,w=$(B,o,n)*B%n,u=$(w,s,n)*w%n,m=$(u,i,n)*u%n,h=$(m,c,n)*m%n,g=$(h,i,n)*u%n,y=$(g,t,n)*l%n,v=$(y,f,n)*w%n,A=$(v,r,n)*a%n,p=$(A,Rt,n);if(!ct.eql(ct.sqr(p),e))throw new Error("Cannot find square root");return p}var ct=he(Ut,void 0,void 0,{sqrt:_e}),Ct=ve({a:BigInt(0),b:BigInt(7),Fp:ct,n:Lt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{let n=Lt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Ae*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,f=BigInt("0x100000000000000000000000000000000"),i=Se(s*e,n),c=Se(-r*e,n),a=H(e-i*t-c*o,n),l=H(-i*r-c*s,n),d=a>f,I=l>f;if(d&&(a=n-a),I&&(l=n-l),a>f||l>f)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:d,k1:a,k2neg:I,k2:l}}}},gt),Zt=BigInt(0),Oe=e=>typeof e=="bigint"&&Zt<e&&e<Ut,cn=e=>typeof e=="bigint"&&Zt<e&&e<Lt,Ie={};function Ht(e,...n){let t=Ie[e];if(t===void 0){let r=gt(Uint8Array.from(e,o=>o.charCodeAt(0)));t=z(r,r),Ie[e]=t}return gt(z(t,...n))}var Ft=e=>e.toRawBytes(!0).slice(1),Qt=e=>Q(e,32),Xt=e=>H(e,Ut),xt=e=>H(e,Lt),te=Ct.ProjectivePoint,fn=(e,n,t)=>te.BASE.multiplyAndAddUnsafe(e,n,t);function Jt(e){let n=Ct.utils.normPrivateKeyToScalar(e),t=te.fromPrivateKey(n);return{scalar:t.hasEvenY()?n:xt(-n),bytes:Ft(t)}}function qe(e){if(!Oe(e))throw new Error("bad x: need 0 < x < p");let n=Xt(e*e),t=Xt(n*e+BigInt(7)),r=_e(t);r%Rt!==Zt&&(r=Xt(-r));let o=new te(e,r,Ae);return o.assertValidity(),o}function Ne(...e){return xt(Z(Ht("BIP0340/challenge",...e)))}function an(e){return Jt(e).bytes}function un(e,n,t=vt(32)){let r=k("message",e),{bytes:o,scalar:s}=Jt(n),f=k("auxRand",t,32),i=Qt(s^Z(Ht("BIP0340/aux",f))),c=Ht("BIP0340/nonce",i,o,r),a=xt(Z(c));if(a===Zt)throw new Error("sign failed: k is zero");let{bytes:l,scalar:d}=Jt(a),I=Ne(l,o,r),B=new Uint8Array(64);if(B.set(l,0),B.set(Qt(xt(d+I*s)),32),!Te(B,r,o))throw new Error("sign: Invalid signature produced");return B}function Te(e,n,t){let r=k("signature",e,64),o=k("message",n),s=k("publicKey",t,32);try{let f=qe(Z(s)),i=Z(r.subarray(0,32));if(!Oe(i))return!1;let c=Z(r.subarray(32,64));if(!cn(c))return!1;let a=Ne(Qt(i),Ft(f),o),l=fn(f,c,xt(-a));return!(!l||!l.hasEvenY()||l.toAffine().x!==i)}catch{return!1}}var Gn=(()=>({getPublicKey:an,sign:un,verify:Te,utils:{randomPrivateKey:Ct.utils.randomPrivateKey,lift_x:qe,pointToBytes:Ft,numberToBytesBE:Q,bytesToNumberBE:Z,taggedHash:Ht,mod:H}}))(),dn=(()=>Ee(ct,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(e=>e.map(n=>BigInt(n)))))(),ln=(()=>ye(ct,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ct.create(BigInt("-11"))}))(),Le=(()=>Be(Ct.ProjectivePoint,e=>{let{x:n,y:t}=ln(ct.create(e[0]));return dn(n,t)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ct.ORDER,m:1,k:128,expand:"xmd",hash:gt}))(),Wn=(()=>Le.hashToCurve)(),Xn=(()=>Le.encodeToCurve)();export{Xn as encodeToCurve,Wn as hashToCurve,Gn as schnorr,Ct as secp256k1};
